# TODO: Add comment
#
# Author: juanbot
###############################################################################



require(WGCNA)
require(gProfileR)


createCentroidMatrix <- function(eigengenes){
  my.matrix <- NULL
  for(eigengene in eigengenes){
    my.matrix <- cbind(my.matrix,eigengene)
  }
  return(my.matrix)
}

getBestModuleCor <- function(gene,centroids,signed=TRUE){

  return(which.max(corDistance(centroids,gene,signed)))
}

#' Function that generates the correlation for distance, in line
#' with a signed network
#' @param a numerical vector with gene expression for gene a
#' @param b numerical vector with gene expression for gene a
#' @param signed is the network signed?
#' @return The signed correlation if signed is TRUE
#' @export
corDistance = function(a,b,signed=TRUE){
  if(signed)
    return(0.5 * (1 + WGCNA::corFast(a,b)))
  return(abs(WGCNA::corFast(a,b)))
}

getNewCentroids <- function(expr.data,partition.in.colors,centroid.labels,mgg){
  if(sum(partition.in.colors == "grey") < mgg)
    eg.vectors = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=TRUE)$eigengenes
  else
    eg.vectors = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=F)$eigengenes

  names(eg.vectors) <- substring(names(eg.vectors),3)
  eg.vectors <- eg.vectors[,centroid.labels]
  return(eg.vectors)
}

getExchangedGenes <- function(old.partition,new.partition){
  stopifnot(length(old.partition) == length(new.partition))
  return(old.partition[old.partition != new.partition])
}

#' This is the main function of the package. It takes a hopefully correctly created WGCN network and,
#' based on gene expression it modifies the module color assignment by using k-means heuristic.
#' The description of the parameters show how the function works.
#' @param net.label This parameter is useful for referring to this specific network at any plot that
#' might be created to monitor the algorithm's behavior
#' @param net.file can be either a full path to a RDS object storing the network or the network itself.
#' We expect a list with objects "moduleColors" and "MEs". The "moduleColors" element si a named vector
#' whose elements are colors as assigned by WGCNA. The names() function should return the gene names for
#' each vector's element. The "MEs" is a matrix with a column for each module and a row for each sample.
#' It contains the module eigengenes. Note that the order of genes in moduleColors is the same as they
#' appear in columns in expr.data parameter's object.
#' @param expr.data is, again, a full path file name or a data frame with genes in columns and samples in
#' rows, giving the expression data used to construct the WGCNA network. The function expects genes in the
#' column order to correspond to the order of nameColors of net.file param.
#' @param  beta The soft threshold parameter as it was used with WGCNA
#' @param n.iterations A max number of iterations to run the k-means
#' @meg Minimum number of genes exchanged: if before the number of iterations, the number of genes exchanged
#' in the current iteration is less than this parameter, the algorithm stops.
#' @param job.path Where to store the files generated by the function
#' @param tom.matrix If the TOM is precalculated, it can be pased as full path file name or as an object.
#' @param plot.evolution If TRUE, it will generate a full set of plots that help making a proper diagnose of
#' the function.
#' @param plot.go If plot.evolution is TRUE and this is also TRUE, it will include in the evolution plot an
#' evaluation of the GO (GEne Ontology) signals obtained from the new partition, in comparision with the
#' original partition obtained by the standard WGCNA
#' @param debug It can be used to set a small number of genes just to run the fuction tentatively before using
#' the whole gene set. May be useful to get a flavour on how the method works.
#' @param net.type it is used in the same sense as WGCNA
#' @param final.net where to store as an RDS object the final network obtained
#' @param min.genes.for.grey The number of genes to consider grey genes as part of the optimization
#' @return The network, post-processed with a k-means heuristic
#' @export
#' @
applykM2WGCNA <- function(net.label,
                          net.file,
                          expr.data,
                          beta=6,
                          n.iterations=20,
                          meg = 20,
                          job.path,
                          tom.matrix=NULL,
                          plot.evolution=TRUE,
                          plot.go=plot.evolution,
                          debug=NULL,
                          net.type="signed",
                          final.net=paste0(job.path,"/",net.label,".",beta,".",net.type,".it.",n.iterations,".rds"),
                          min.genes.for.grey=20){

  if(typeof(expr.data) == "character")
    expr.data <- readRDS(expr.data)

  if(!is.null(debug)){
    cat("We are debugging, using only ",debug,"genes from gene expression\n")
    expr.data = expr.data[,1:as.numeric(debug)]
  }
  cat("Working with",nrow(expr.data),"samples and",ncol(expr.data),"genes\n")

  #Step 2
  if(typeof(net.file) == "character"){
    print("Loading network")
    net <- readRDS(net.file)
  }else
    net = net.file

  if(!is.null(debug)){
    cat("We are debugging, using only ",debug,"genes from the source GCN\n")
    net$moduleColors = net$moduleColors[1:as.numeric(debug)]
    mods = unique(net$moduleColors)

    #Get rid of the MEs not found in mods
    mods = paste0("ME",mods)
    net$MEs = net$MEs[,colnames(net$MEs) %in% mods]
  }
  cat("The network includes",net$moduleColors,"genes and ",
      length(unique(net$moduleColors)),"modules\n")

  if(plot.evolution){
    plot.evolution.file <- paste0(final.net,".evkM.pdf")
    cat("Evolution will be plotted at",plot.evolution.file,"\n")
    if(plot.go){
      go.file <- paste0(final.net,".gokM.rds")
      print(paste0("GO analysis will be at  ",go.file))
    }else
      go.file = NULL
  }

  partitions.file <- paste0(final.net,".parts.rds")
  cat("Partitions data will be at",partitions.file,"\n")


  #ALGORITHM SPECIFICATION
  #Step 1. Let D be the expression data in which dij in D represents the expression value for
  #sample i and gene j, being s samples and g genes in total.
  #Step 2. Construct the partition by the WGCNA process, let P_D={m_1, m_2, ..., m_n} be
  #that partition where m_k is the k-th module.
  #Step 3. Get the eigengenes for each module within the partition, E={e_1, e_2, ..., e_n}
  #Step 4. Set up the k-means clustering
  #Step 4.1. Set k to n
  #Step 4.2. Set the centroids C to the eigengenes E, thus C to E
  #Step 5. Run the algorithm and monitor its evolution
  #Step 5.1 Set iterations to 0
  #Step 5.2 Create a new partition P', given C with n modules such that, for each gene, 1 <=
  #		j <= g, g_j belongs to the module c_t in C such that a distance meassure d(g_j,c_t) is
  #		minimum.
  #		Step 5.3 Calculate eigengenes of P', giving a new E'
  #		Step 5.4 Evaluate the progress. If progress done, set iterations to iterations + 1 and
  #		C to E' and go to step 5.2
  #Step 5.5 Finish
  #

  #Gather the current partition we start from
  partition.in.colors <- net$moduleColors
  #print(head(partition.in.colors,5))

  print("Getting initial eigengenes")
  if(sum(partition.in.colors == "grey") < min.genes.for.grey)
    eigengenes = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=TRUE)
  else
    eigengenes = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=F)

  cat("We got",length(eigengenes$eigengenes)," eigengene vectors\n")
  print(head(eigengenes$eigengenes))

  #This variable is fixed and used as a reference to indicate the
  #modules used (they are colours but the position within the vector is
  #also relevant)
  centroid.labels <- substring(names(eigengenes$eigengenes),3)
  print("Module colors are")
  print(head(centroid.labels))

  k <- length(eigengenes$eigengenes)
  #Centroids must be a matrix with as much colums as centroids,
  #as much rows as samples
  centroids <- createCentroidMatrix(eigengenes$eigengenes)


  print("We have generated centroids")
  print(head(centroids))


  #Step 5
  #For storage of all the partitions created during the iterations
  partitions <- list()
  #A partition will be a list of as much elements as genes and for the
  #i-th position it stores the index of the module the ith gene belongs
  #to, and the color can be found in "centroid.labels"
  print("From partition ")
  print(head(partition.in.colors))
  print("We create ")
  new.partition <- match(partition.in.colors, centroid.labels)
  print(head(new.partition))
  names(new.partition) <- centroid.labels[new.partition]
  partitions[[1]] <- new.partition


  #Launch the iterations
  exchanged.genes = meg + 1
  iteration = 1

  while(exchanged.genes > meg & iteration <= n.iterations){

    #for(iteration in 1:n.iterations){
    print(paste0("Starting partition ",iteration))
    print(paste0("Number of centroids before getting new partition ",ncol(centroids)))

    new.partition <- apply(expr.data,MARGIN=2,getBestModuleCor,centroids=centroids,
                           signed=(net.type == "signed"))

    partitions[[iteration + 1]] <- new.partition
    #Get the control values for the new partition
    exchanged.gene.count <- length(getExchangedGenes(partitions[[iteration]],
                                                     partitions[[iteration + 1]]))
    cat("A total of ", exchanged.gene.count,
        " genes moved to another partition\n")

    new.partition.in.colors <- centroid.labels[unlist(new.partition)]
    centroids <- getNewCentroids(expr.data,new.partition.in.colors,centroid.labels,min.genes.for.grey)

    exchanged.genes = exchanged.gene.count
    iteration = iteration + 1
  }
  cat("We finish with",iteration,"iterations\n")
  cat("Last number of gene changes where",exchanged.genes,"\n")
  saveRDS(partitions,partitions.file)

  if(plot.evolution)
    plotEvolution(net.label=net.label,
                  net=net,
                  tom=tom.matrix,
                  beta=beta,
                  expr.data=expr.data,
                  net.type=net.type,
                  module.colors=centroid.labels,
                  partitions=partitions,
                  plot.evolution.file=plot.evolution.file,
                  go.file=go.file)

  print("The algorithm finished correctly")
  return(genNetFromPartition(expr.data.file=expr.data,
                             beta=beta,
                             partitions.file=partitions.file,
                             mgg=min.genes.for.grey,index=-1))
}

genNetFromPartition <- function(expr.data.file,
                                beta,
                                partitions.file,
                                mgg,
                                index=-1){

  parts <- readRDS(partitions.file)

  if(index < 0)
    index = length(parts)

  colors = unique(names(parts[[1]]))
  col.number = unique(parts[[1]])

  if(typeof(expr.data.file) == "character")
    expr.data = readRDS(expr.data.file)
  else
    expr.data = expr.data.file

  new.net <- NULL
  if(index == 1){
    new.net$moduleLabels = parts[[index]]
    new.net$moduleColors = names(parts[[index]])
    names(new.net$moduleColors) = colnames(expr.data)
    names(new.net$moduleLabels) = colnames(expr.data)

  }else{
    new.net$moduleLabels = parts[[index]]
    new.net$moduleColors = colors[match(parts[[index]],col.number)]
    names(new.net$moduleColors) = colnames(expr.data)
    names(new.net$moduleLabels) = colnames(expr.data)

  }

  #If there are some grey genes as NA, add them again
  new.net$moduleColors[is.na(new.net$moduleColors)] = "grey"

  if(sum(new.net$moduleColors == "grey") >= mgg)
    new.net$MEs <- moduleEigengenes(expr.data,new.net$moduleColors,softPower=beta, excludeGrey=F)$eigengenes
  else
    new.net$MEs <- moduleEigengenes(expr.data,new.net$moduleColors,softPower=beta, excludeGrey=T)$eigengenes

  return(new.net)
}

plotEvolution <- function(net.label,net,
                          module.colors=unique(net$moduleColors),
                          partitions,
                          tom=NULL,
                          beta,
                          expr.data,
                          net.type,
                          plot.evolution.file,
                          modules=NULL,
                          go.file){

  if(is.null(tom)){
    cat("We have to create a TOM matrix from the WGCNA network, with beta",beta,
        "and net type",net.type,"\n")
    #Now we create the TOM
    adjacency = adjacency(expr.data, power = beta, type = net.type )
    tom.matrix = TOMsimilarity(adjacency)
    cat("The tom matrix has been generated\n")
  }else if(typeof(tom) == "character"){
    cat("TOM matrix loaded from file",tom,"\n")
    tom.matrix = readRDS(tom)
  }else{
    cat("TOM matrix passed as argument\n")
    tom.matrix = tom
  }

  pdf(plot.evolution.file,width=15,height=12)
  par(mfrow=c(4,3))
  g.changes = NULL
  n = length(partitions)
  for(index in 1:(n-1)){
    g.changes = c(g.changes,sum(partitions[[index]] != partitions[[index + 1]]))
  }
  plot(1:(length(partitions)-1),g.changes,
       main=paste0(net.label," exchanged genes"),xlab="iteration")

  if(is.null(modules)){
    modules <- 1:length(module.colors)
  }

  if(!is.null(go.file))
    saveRDS(plotGOenrichment(net.label,net,partitions,module.colors),go.file)


  #Lets plot module size evolution
  sizes <- matrix(nrow=length(modules),ncol=n)
  sizes <- lapply(partitions,function(x){
    s <- lapply(1:length(module.colors),function(y,x){
      size <- table(x == y)["TRUE"]
    },x=x)
  })
  min.size <- min(unlist(lapply(partitions,function(x){ return(min(table(x))) })))
  max.size <- max(unlist(lapply(partitions,function(x){ return(max(table(x))) })))

  plot(1:n,lapply(sizes,function(x){ x[[1]]}),
       main=paste0(net.label, " module sizes (",length(sizes)," modules)"),
       col=module.colors[modules[1]],ylim=c(min.size,max.size),t="l")
  for(index in 2:length(modules))
    lines(1:n,lapply(sizes,function(x){ x[[index]]}),col=module.colors[modules[index]])

  if(!is.null(tom.matrix)){
    #Calc adjacency
    adjacency <- matrix(nrow=n,ncol=length(modules))
    max.y <- 0
    min.y <- 1000
    for(module.index in 1:length(modules)){
      for(element in 1:n){
        genes.in.module = partitions[[element]] == modules[module.index]

        #grey will generane NAs. Change to F
        genes.in.module[is.na(genes.in.module)] = F

        if(all(!genes.in.module)){
          print("Module has zero genes ")
        }
        #print(genes.in.module)
        adjacency[element,module.index] = sum(tom.matrix[genes.in.module,genes.in.module])/table(genes.in.module)["TRUE"]
      }
    }

    #Plot adjacency
    max.y <- max(adjacency)
    min.y <- min(adjacency)
    if(is.infinite(max.y))
      max.y = 50
    if(is.infinite(min.y))
      min.y = 0
    cat("Plotting adjacency",c(min.y,max.y),"\n")
    plot(1:n,adjacency[,1],main=paste0(net.label, " adjacency"),ylim=c(min.y,max.y),col=module.colors[modules[1]])
    for(module in modules[-1])
      lines(1:n,adjacency[,module],col=module.colors[module])

    #Plot adjacency entropy
    entropies <- list()
    for(element in 1:n){
      ps <- adjacency[element,]/max(adjacency[element,])
      entropies[[element]] <- -sum(ps * log10(ps))
    }
    cat("Plotting entropy",c(min.y,max.y),"\n")
    plot(1:n,entropies,main=paste0(net.label, " adjacency entropy"),t="l")
  }

  #Plot number of genes exchanged in modules by iteration
  genes.exchanged <- matrix(nrow=(n-1),ncol=length(modules))
  for(module.index in 1:length(modules)){
    for(element in 1:(n - 1)){
      genes.in.module.old <- partitions[[element]] == modules[module.index]
      genes.in.module.new <- partitions[[element + 1]] == modules[module.index]
      genes.exchanged[element,module.index] = table(genes.in.module.old != genes.in.module.new)["TRUE"]
      if(is.na(genes.exchanged[element,module.index]))
        genes.exchanged[element,module.index] <- 0
    }
  }
  max.y <- max(genes.exchanged)
  min.y <- 0
  if(is.infinite(max.y))
    max.y = 4000

  plot(1:(n-1),genes.exchanged[,1],main=paste0(net.label, "gene changes"),
       ylim=c(min.y,max.y),col=module.colors[modules[1]],t="l")
  for(module in modules[-1])
    lines(1:(n-1),genes.exchanged[,module],col=module.colors[module])

  dev.off()

}

plotGOenrichment <- function(net.label,
                             net,
                             partitions,
                             go.file=NULL,
                             plot.file=NULL,
                             filter="GO",
                             exclude.iea=T,
                             gprof.method="gSCS"){


  gene.names <- names(net$moduleColors)
  background = gene.names
  modules <- unique(net$moduleColors)
  module.colors = modules

  enrichment <- matrix(nrow=length(partitions),ncol=length(modules))
  new.terms <- matrix(nrow=length(partitions),ncol=length(modules))
  lost.terms <- matrix(nrow=length(partitions),ncol=length(modules))
  highly.signif.terms <- matrix(nrow=length(partitions),ncol=length(modules))

  colnames(enrichment) <- modules
  colnames(new.terms) <- modules
  colnames(lost.terms) <- modules

  enrichment[,] <- 0

  partition.index <- 1

  goresults <- list()

  #Adjust 1st partition to the rest
  names(partitions[[1]]) <- names(partitions[[2]])

  names(partitions[[length(partitions)]]) = names(partitions[[2]])
  partitions.to.plot <- partitions[c(1,length(partitions))]

  for(partition in partitions.to.plot){
    print(paste0("Going for enrichment in iteration ", partition.index))

    all.genes <- NULL
    for(module in modules){

      all.genes[[module]] = names(partition)[partition == which(module.colors == module)]
    }
    go <- gprofiler(query=all.genes,correction_method=gprof.method,exclude_iea=exclude.iea,
                    custom_bg=background,src_filter=filter)

    goresults[[partition.index]] <- go
    #Transforming p values in log10 scale
    en.modules <- unique(go$query.number)
    for(module in en.modules){
      enrichment[partition.index,module] <- sum(-log10(go$p.value[go$query.number == module]))
      if(partition.index == 1){
        new.terms[partition.index,module] <- 0
      }else{
        old.go <- goresults[[partition.index - 1]]
        intersect.go <- intersect(old.go$term.id[old.go$query.number == module],
                                  go$term.id[go$query.number == module])
        new.terms[partition.index,module] <- length(setdiff(go$term.id[go$query.number == module],
                                                            intersect.go))

        lost.terms[partition.index,module] <- length(setdiff(old.go$term.id[old.go$query.number == module],
                                                             intersect.go))
        new.terms[is.na(new.terms[,])] <- 0
        lost.terms[is.na(lost.terms[,])] <- 0
      }
    }
    partition.index <- partition.index + 1
  }

  if(!is.null(plot.file)){
    pdf(plot.file,width=20,height=10)
    old.par <- par()
    par(mfrow=c(1,3))
  }
  vals.to.plot <- enrichment[2,]-enrichment[1,]
  vals.to.plot <-  c(vals.to.plot,sum(enrichment[2,])-sum(enrichment[1,]))
  order.to.plot = order(vals.to.plot,decreasing=TRUE)
  mod.cols <- c(modules,"gold")
  barplot(vals.to.plot[order.to.plot],col=mod.cols[order.to.plot],
          main=paste0(net.label, ": GO gain after post-processing WGNCA"),xlab="Network modules",
          ylab="sum(-log10(pval))" )

  vals.to.plot <- new.terms[2,]-new.terms[1,]
  vals.to.plot <-  c(vals.to.plot,sum(new.terms[2,])-sum(new.terms[1,]))
  order.to.plot = order(vals.to.plot,decreasing=TRUE)
  barplot(vals.to.plot[order.to.plot],col=mod.cols[order.to.plot],
          main=paste0(net.label,": new terms by module"),xlab="Network modules",ylab="# terms")

  vals.to.plot <- lost.terms[2,]-lost.terms[1,]
  vals.to.plot <-  c(vals.to.plot,sum(lost.terms[2,])-sum(lost.terms[1,]))
  order.to.plot = order(vals.to.plot,decreasing=TRUE)

  barplot(vals.to.plot[order.to.plot],col=mod.cols[order.to.plot],
          main=paste0(net.label,": lost terms by module"),xlab="Network modules",ylab="# terms")

  if(!is.null(plot.file)){
    par(old.par)
    dev.off()
  }

  return(list(enrichment=enrichment,goresults=goresults))
}


