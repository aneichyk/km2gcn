{
    "collab_server" : "",
    "contents" : "# TODO: Add comment\n#\n# Author: juanbot\n###############################################################################\n\n\n\nrequire(WGCNA)\nrequire(gProfileR)\n\n\ncreateCentroidMatrix <- function(eigengenes){\n  my.matrix <- NULL\n  for(eigengene in eigengenes){\n    my.matrix <- cbind(my.matrix,eigengene)\n  }\n  return(my.matrix)\n}\n\ngetBestModuleCor <- function(gene,centroids,signed=TRUE){\n\n  return(which.max(corDistance(centroids,gene,signed)))\n}\n\n#' Function that generates the correlation for distance, in line\n#' with a signed network\n#' @param a numerical vector with gene expression for gene a\n#' @param b numerical vector with gene expression for gene a\n#' @param signed is the network signed?\n#' @return The signed correlation if signed is TRUE\n#' @export\ncorDistance = function(a,b,signed=TRUE){\n  if(signed)\n    return(0.5 * (1 + WGCNA::corFast(a,b)))\n  return(abs(WGCNA::corFast(a,b)))\n}\n\ngetNewCentroids <- function(expr.data,partition.in.colors,centroid.labels,mgg){\n  if(sum(partition.in.colors == \"grey\") < mgg)\n    eg.vectors = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=TRUE)$eigengenes\n  else\n    eg.vectors = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=F)$eigengenes\n\n  names(eg.vectors) <- substring(names(eg.vectors),3)\n  eg.vectors <- eg.vectors[,centroid.labels]\n  return(eg.vectors)\n}\n\ngetExchangedGenes <- function(old.partition,new.partition){\n  stopifnot(length(old.partition) == length(new.partition))\n  return(old.partition[old.partition != new.partition])\n}\n\n#' This is the main function of the package. It takes a hopefully correctly created WGCN network and,\n#' based on gene expression it modifies the module color assignment by using k-means heuristic.\n#' The description of the parameters show how the function works.\n#' @param net.label This parameter is useful for referring to this specific network at any plot that\n#' might be created to monitor the algorithm's behavior\n#' @param net.file can be either a full path to a RDS object storing the network or the network itself.\n#' We expect a list with objects \"moduleColors\" and \"MEs\". The \"moduleColors\" element si a named vector\n#' whose elements are colors as assigned by WGCNA. The names() function should return the gene names for\n#' each vector's element. The \"MEs\" is a matrix with a column for each module and a row for each sample.\n#' It contains the module eigengenes. Note that the order of genes in moduleColors is the same as they\n#' appear in columns in expr.data parameter's object.\n#' @param expr.data is, again, a full path file name or a data frame with genes in columns and samples in\n#' rows, giving the expression data used to construct the WGCNA network. The function expects genes in the\n#' column order to correspond to the order of nameColors of net.file param.\n#' @param  beta The soft threshold parameter as it was used with WGCNA\n#' @param n.iterations A max number of iterations to run the k-means\n#' @meg Minimum number of genes exchanged: if before the number of iterations, the number of genes exchanged\n#' in the current iteration is less than this parameter, the algorithm stops.\n#' @param job.path Where to store the files generated by the function\n#' @param tom.matrix If the TOM is precalculated, it can be pased as full path file name or as an object.\n#' @param plot.evolution If TRUE, it will generate a full set of plots that help making a proper diagnose of\n#' the function.\n#' @param plot.go If plot.evolution is TRUE and this is also TRUE, it will include in the evolution plot an\n#' evaluation of the GO (GEne Ontology) signals obtained from the new partition, in comparision with the\n#' original partition obtained by the standard WGCNA\n#' @param debug It can be used to set a small number of genes just to run the fuction tentatively before using\n#' the whole gene set. May be useful to get a flavour on how the method works.\n#' @param net.type it is used in the same sense as WGCNA\n#' @param final.net where to store as an RDS object the final network obtained\n#' @param min.genes.for.grey The number of genes to consider grey genes as part of the optimization\n#' @return The network, post-processed with a k-means heuristic\n#' @export\n#' @\napplykM2WGCNA <- function(net.label,\n                          net.file,\n                          expr.data,\n                          beta=6,\n                          n.iterations=20,\n                          meg = 20,\n                          job.path,\n                          tom.matrix=NULL,\n                          plot.evolution=TRUE,\n                          plot.go=plot.evolution,\n                          debug=NULL,\n                          net.type=\"signed\",\n                          final.net=paste0(job.path,\"/\",net.label,\".\",beta,\".\",net.type,\".it.\",n.iterations,\".rds\"),\n                          min.genes.for.grey=20){\n\n  if(typeof(expr.data) == \"character\")\n    expr.data <- readRDS(expr.data)\n\n  if(!is.null(debug)){\n    cat(\"We are debugging, using only \",debug,\"genes from gene expression\\n\")\n    expr.data = expr.data[,1:as.numeric(debug)]\n  }\n  cat(\"Working with\",nrow(expr.data),\"samples and\",ncol(expr.data),\"genes\\n\")\n\n  #Step 2\n  if(typeof(net.file) == \"character\"){\n    print(\"Loading network\")\n    net <- readRDS(net.file)\n  }else\n    net = net.file\n\n  if(!is.null(debug)){\n    cat(\"We are debugging, using only \",debug,\"genes from the source GCN\\n\")\n    net$moduleColors = net$moduleColors[1:as.numeric(debug)]\n    mods = unique(net$moduleColors)\n\n    #Get rid of the MEs not found in mods\n    mods = paste0(\"ME\",mods)\n    net$MEs = net$MEs[,colnames(net$MEs) %in% mods]\n  }\n  cat(\"The network includes\",net$moduleColors,\"genes and \",\n      length(unique(net$moduleColors)),\"modules\\n\")\n\n  if(plot.evolution){\n    plot.evolution.file <- paste0(final.net,\".evkM.pdf\")\n    cat(\"Evolution will be plotted at\",plot.evolution.file,\"\\n\")\n    if(plot.go){\n      go.file <- paste0(final.net,\".gokM.rds\")\n      print(paste0(\"GO analysis will be at  \",go.file))\n    }else\n      go.file = NULL\n  }\n\n  partitions.file <- paste0(final.net,\".parts.rds\")\n  cat(\"Partitions data will be at\",partitions.file,\"\\n\")\n\n\n  #ALGORITHM SPECIFICATION\n  #Step 1. Let D be the expression data in which dij in D represents the expression value for\n  #sample i and gene j, being s samples and g genes in total.\n  #Step 2. Construct the partition by the WGCNA process, let P_D={m_1, m_2, ..., m_n} be\n  #that partition where m_k is the k-th module.\n  #Step 3. Get the eigengenes for each module within the partition, E={e_1, e_2, ..., e_n}\n  #Step 4. Set up the k-means clustering\n  #Step 4.1. Set k to n\n  #Step 4.2. Set the centroids C to the eigengenes E, thus C to E\n  #Step 5. Run the algorithm and monitor its evolution\n  #Step 5.1 Set iterations to 0\n  #Step 5.2 Create a new partition P', given C with n modules such that, for each gene, 1 <=\n  #\t\tj <= g, g_j belongs to the module c_t in C such that a distance meassure d(g_j,c_t) is\n  #\t\tminimum.\n  #\t\tStep 5.3 Calculate eigengenes of P', giving a new E'\n  #\t\tStep 5.4 Evaluate the progress. If progress done, set iterations to iterations + 1 and\n  #\t\tC to E' and go to step 5.2\n  #Step 5.5 Finish\n  #\n\n  #Gather the current partition we start from\n  partition.in.colors <- net$moduleColors\n  #print(head(partition.in.colors,5))\n\n  print(\"Getting initial eigengenes\")\n  if(sum(partition.in.colors == \"grey\") < min.genes.for.grey)\n    eigengenes = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=TRUE)\n  else\n    eigengenes = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=F)\n\n  cat(\"We got\",length(eigengenes$eigengenes),\" eigengene vectors\\n\")\n  print(head(eigengenes$eigengenes))\n\n  #This variable is fixed and used as a reference to indicate the\n  #modules used (they are colours but the position within the vector is\n  #also relevant)\n  centroid.labels <- substring(names(eigengenes$eigengenes),3)\n  print(\"Module colors are\")\n  print(head(centroid.labels))\n\n  k <- length(eigengenes$eigengenes)\n  #Centroids must be a matrix with as much colums as centroids,\n  #as much rows as samples\n  centroids <- createCentroidMatrix(eigengenes$eigengenes)\n\n\n  print(\"We have generated centroids\")\n  print(head(centroids))\n\n\n  #Step 5\n  #For storage of all the partitions created during the iterations\n  partitions <- list()\n  #A partition will be a list of as much elements as genes and for the\n  #i-th position it stores the index of the module the ith gene belongs\n  #to, and the color can be found in \"centroid.labels\"\n  print(\"From partition \")\n  print(head(partition.in.colors))\n  print(\"We create \")\n  new.partition <- match(partition.in.colors, centroid.labels)\n  print(head(new.partition))\n  names(new.partition) <- centroid.labels[new.partition]\n  partitions[[1]] <- new.partition\n\n\n  #Launch the iterations\n  exchanged.genes = meg + 1\n  iteration = 1\n\n  while(exchanged.genes > meg & iteration <= n.iterations){\n\n    #for(iteration in 1:n.iterations){\n    print(paste0(\"Starting partition \",iteration))\n    print(paste0(\"Number of centroids before getting new partition \",ncol(centroids)))\n\n    new.partition <- apply(expr.data,MARGIN=2,getBestModuleCor,centroids=centroids,\n                           signed=(net.type == \"signed\"))\n\n    partitions[[iteration + 1]] <- new.partition\n    #Get the control values for the new partition\n    exchanged.gene.count <- length(getExchangedGenes(partitions[[iteration]],\n                                                     partitions[[iteration + 1]]))\n    cat(\"A total of \", exchanged.gene.count,\n        \" genes moved to another partition\\n\")\n\n    new.partition.in.colors <- centroid.labels[unlist(new.partition)]\n    centroids <- getNewCentroids(expr.data,new.partition.in.colors,centroid.labels,min.genes.for.grey)\n\n    exchanged.genes = exchanged.gene.count\n    iteration = iteration + 1\n  }\n  cat(\"We finish with\",iteration,\"iterations\\n\")\n  cat(\"Last number of gene changes where\",exchanged.genes,\"\\n\")\n  saveRDS(partitions,partitions.file)\n\n  if(plot.evolution)\n    plotEvolution(net.label=net.label,\n                  net=net,\n                  tom=tom.matrix,\n                  beta=beta,\n                  expr.data=expr.data,\n                  net.type=net.type,\n                  module.colors=centroid.labels,\n                  partitions=partitions,\n                  plot.evolution.file=plot.evolution.file,\n                  go.file=go.file)\n\n  print(\"The algorithm finished correctly\")\n  return(genNetFromPartition(expr.data.file=expr.data,\n                             beta=beta,\n                             partitions.file=partitions.file,\n                             mgg=min.genes.for.grey,index=-1))\n}\n\ngenNetFromPartition <- function(expr.data.file,\n                                beta,\n                                partitions.file,\n                                mgg,\n                                index=-1){\n\n  parts <- readRDS(partitions.file)\n\n  if(index < 0)\n    index = length(parts)\n\n  colors = unique(names(parts[[1]]))\n  col.number = unique(parts[[1]])\n\n  if(typeof(expr.data.file) == \"character\")\n    expr.data = readRDS(expr.data.file)\n  else\n    expr.data = expr.data.file\n\n  new.net <- NULL\n  if(index == 1){\n    new.net$moduleLabels = parts[[index]]\n    new.net$moduleColors = names(parts[[index]])\n    names(new.net$moduleColors) = colnames(expr.data)\n    names(new.net$moduleLabels) = colnames(expr.data)\n\n  }else{\n    new.net$moduleLabels = parts[[index]]\n    new.net$moduleColors = colors[match(parts[[index]],col.number)]\n    names(new.net$moduleColors) = colnames(expr.data)\n    names(new.net$moduleLabels) = colnames(expr.data)\n\n  }\n\n  #If there are some grey genes as NA, add them again\n  new.net$moduleColors[is.na(new.net$moduleColors)] = \"grey\"\n\n  if(sum(new.net$moduleColors == \"grey\") >= mgg)\n    new.net$MEs <- moduleEigengenes(expr.data,new.net$moduleColors,softPower=beta, excludeGrey=F)$eigengenes\n  else\n    new.net$MEs <- moduleEigengenes(expr.data,new.net$moduleColors,softPower=beta, excludeGrey=T)$eigengenes\n\n  return(new.net)\n}\n\nplotEvolution <- function(net.label,net,\n                          module.colors=unique(net$moduleColors),\n                          partitions,\n                          tom=NULL,\n                          beta,\n                          expr.data,\n                          net.type,\n                          plot.evolution.file,\n                          modules=NULL,\n                          go.file){\n\n  if(is.null(tom)){\n    cat(\"We have to create a TOM matrix from the WGCNA network, with beta\",beta,\n        \"and net type\",net.type,\"\\n\")\n    #Now we create the TOM\n    adjacency = adjacency(expr.data, power = beta, type = net.type )\n    tom.matrix = TOMsimilarity(adjacency)\n    cat(\"The tom matrix has been generated\\n\")\n  }else if(typeof(tom) == \"character\"){\n    cat(\"TOM matrix loaded from file\",tom,\"\\n\")\n    tom.matrix = readRDS(tom)\n  }else{\n    cat(\"TOM matrix passed as argument\\n\")\n    tom.matrix = tom\n  }\n\n  pdf(plot.evolution.file,width=15,height=12)\n  par(mfrow=c(4,3))\n  g.changes = NULL\n  n = length(partitions)\n  for(index in 1:(n-1)){\n    g.changes = c(g.changes,sum(partitions[[index]] != partitions[[index + 1]]))\n  }\n  plot(1:(length(partitions)-1),g.changes,\n       main=paste0(net.label,\" exchanged genes\"),xlab=\"iteration\")\n\n  if(is.null(modules)){\n    modules <- 1:length(module.colors)\n  }\n\n  if(!is.null(go.file))\n    saveRDS(plotGOenrichment(net.label,net,partitions,module.colors),go.file)\n\n\n  #Lets plot module size evolution\n  sizes <- matrix(nrow=length(modules),ncol=n)\n  sizes <- lapply(partitions,function(x){\n    s <- lapply(1:length(module.colors),function(y,x){\n      size <- table(x == y)[\"TRUE\"]\n    },x=x)\n  })\n  min.size <- min(unlist(lapply(partitions,function(x){ return(min(table(x))) })))\n  max.size <- max(unlist(lapply(partitions,function(x){ return(max(table(x))) })))\n\n  plot(1:n,lapply(sizes,function(x){ x[[1]]}),\n       main=paste0(net.label, \" module sizes (\",length(sizes),\" modules)\"),\n       col=module.colors[modules[1]],ylim=c(min.size,max.size),t=\"l\")\n  for(index in 2:length(modules))\n    lines(1:n,lapply(sizes,function(x){ x[[index]]}),col=module.colors[modules[index]])\n\n  if(!is.null(tom.matrix)){\n    #Calc adjacency\n    adjacency <- matrix(nrow=n,ncol=length(modules))\n    max.y <- 0\n    min.y <- 1000\n    for(module.index in 1:length(modules)){\n      for(element in 1:n){\n        genes.in.module = partitions[[element]] == modules[module.index]\n\n        #grey will generane NAs. Change to F\n        genes.in.module[is.na(genes.in.module)] = F\n\n        if(all(!genes.in.module)){\n          print(\"Module has zero genes \")\n        }\n        #print(genes.in.module)\n        adjacency[element,module.index] = sum(tom.matrix[genes.in.module,genes.in.module])/table(genes.in.module)[\"TRUE\"]\n      }\n    }\n\n    #Plot adjacency\n    max.y <- max(adjacency)\n    min.y <- min(adjacency)\n    if(is.infinite(max.y))\n      max.y = 50\n    if(is.infinite(min.y))\n      min.y = 0\n    cat(\"Plotting adjacency\",c(min.y,max.y),\"\\n\")\n    plot(1:n,adjacency[,1],main=paste0(net.label, \" adjacency\"),ylim=c(min.y,max.y),col=module.colors[modules[1]])\n    for(module in modules[-1])\n      lines(1:n,adjacency[,module],col=module.colors[module])\n\n    #Plot adjacency entropy\n    entropies <- list()\n    for(element in 1:n){\n      ps <- adjacency[element,]/max(adjacency[element,])\n      entropies[[element]] <- -sum(ps * log10(ps))\n    }\n    cat(\"Plotting entropy\",c(min.y,max.y),\"\\n\")\n    plot(1:n,entropies,main=paste0(net.label, \" adjacency entropy\"),t=\"l\")\n  }\n\n  #Plot number of genes exchanged in modules by iteration\n  genes.exchanged <- matrix(nrow=(n-1),ncol=length(modules))\n  for(module.index in 1:length(modules)){\n    for(element in 1:(n - 1)){\n      genes.in.module.old <- partitions[[element]] == modules[module.index]\n      genes.in.module.new <- partitions[[element + 1]] == modules[module.index]\n      genes.exchanged[element,module.index] = table(genes.in.module.old != genes.in.module.new)[\"TRUE\"]\n      if(is.na(genes.exchanged[element,module.index]))\n        genes.exchanged[element,module.index] <- 0\n    }\n  }\n  max.y <- max(genes.exchanged)\n  min.y <- 0\n  if(is.infinite(max.y))\n    max.y = 4000\n\n  plot(1:(n-1),genes.exchanged[,1],main=paste0(net.label, \"gene changes\"),\n       ylim=c(min.y,max.y),col=module.colors[modules[1]],t=\"l\")\n  for(module in modules[-1])\n    lines(1:(n-1),genes.exchanged[,module],col=module.colors[module])\n\n  dev.off()\n\n}\n\nplotGOenrichment <- function(net.label,\n                             net,\n                             partitions,\n                             go.file=NULL,\n                             plot.file=NULL,\n                             filter=\"GO\",\n                             exclude.iea=T,\n                             gprof.method=\"gSCS\"){\n\n\n  gene.names <- names(net$moduleColors)\n  background = gene.names\n  modules <- unique(net$moduleColors)\n  module.colors = modules\n\n  enrichment <- matrix(nrow=length(partitions),ncol=length(modules))\n  new.terms <- matrix(nrow=length(partitions),ncol=length(modules))\n  lost.terms <- matrix(nrow=length(partitions),ncol=length(modules))\n  highly.signif.terms <- matrix(nrow=length(partitions),ncol=length(modules))\n\n  colnames(enrichment) <- modules\n  colnames(new.terms) <- modules\n  colnames(lost.terms) <- modules\n\n  enrichment[,] <- 0\n\n  partition.index <- 1\n\n  goresults <- list()\n\n  #Adjust 1st partition to the rest\n  names(partitions[[1]]) <- names(partitions[[2]])\n\n  names(partitions[[length(partitions)]]) = names(partitions[[2]])\n  partitions.to.plot <- partitions[c(1,length(partitions))]\n\n  for(partition in partitions.to.plot){\n    print(paste0(\"Going for enrichment in iteration \", partition.index))\n\n    all.genes <- NULL\n    for(module in modules){\n\n      all.genes[[module]] = names(partition)[partition == which(module.colors == module)]\n    }\n    go <- gprofiler(query=all.genes,correction_method=gprof.method,exclude_iea=exclude.iea,\n                    custom_bg=background,src_filter=filter)\n\n    goresults[[partition.index]] <- go\n    #Transforming p values in log10 scale\n    en.modules <- unique(go$query.number)\n    for(module in en.modules){\n      enrichment[partition.index,module] <- sum(-log10(go$p.value[go$query.number == module]))\n      if(partition.index == 1){\n        new.terms[partition.index,module] <- 0\n      }else{\n        old.go <- goresults[[partition.index - 1]]\n        intersect.go <- intersect(old.go$term.id[old.go$query.number == module],\n                                  go$term.id[go$query.number == module])\n        new.terms[partition.index,module] <- length(setdiff(go$term.id[go$query.number == module],\n                                                            intersect.go))\n\n        lost.terms[partition.index,module] <- length(setdiff(old.go$term.id[old.go$query.number == module],\n                                                             intersect.go))\n        new.terms[is.na(new.terms[,])] <- 0\n        lost.terms[is.na(lost.terms[,])] <- 0\n      }\n    }\n    partition.index <- partition.index + 1\n  }\n\n  if(!is.null(plot.file)){\n    pdf(plot.file,width=20,height=10)\n    old.par <- par()\n    par(mfrow=c(1,3))\n  }\n  vals.to.plot <- enrichment[2,]-enrichment[1,]\n  vals.to.plot <-  c(vals.to.plot,sum(enrichment[2,])-sum(enrichment[1,]))\n  order.to.plot = order(vals.to.plot,decreasing=TRUE)\n  mod.cols <- c(modules,\"gold\")\n  barplot(vals.to.plot[order.to.plot],col=mod.cols[order.to.plot],\n          main=paste0(net.label, \": GO gain after post-processing WGNCA\"),xlab=\"Network modules\",\n          ylab=\"sum(-log10(pval))\" )\n\n  vals.to.plot <- new.terms[2,]-new.terms[1,]\n  vals.to.plot <-  c(vals.to.plot,sum(new.terms[2,])-sum(new.terms[1,]))\n  order.to.plot = order(vals.to.plot,decreasing=TRUE)\n  barplot(vals.to.plot[order.to.plot],col=mod.cols[order.to.plot],\n          main=paste0(net.label,\": new terms by module\"),xlab=\"Network modules\",ylab=\"# terms\")\n\n  vals.to.plot <- lost.terms[2,]-lost.terms[1,]\n  vals.to.plot <-  c(vals.to.plot,sum(lost.terms[2,])-sum(lost.terms[1,]))\n  order.to.plot = order(vals.to.plot,decreasing=TRUE)\n\n  barplot(vals.to.plot[order.to.plot],col=mod.cols[order.to.plot],\n          main=paste0(net.label,\": lost terms by module\"),xlab=\"Network modules\",ylab=\"# terms\")\n\n  if(!is.null(plot.file)){\n    par(old.par)\n    dev.off()\n  }\n\n  return(list(enrichment=enrichment,goresults=goresults))\n}\n\n\n",
    "created" : 1464020313186.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3668795043",
    "id" : "3E58EE6D",
    "lastKnownWriteTime" : 1464083389,
    "last_content_update" : 1464083389820,
    "path" : "~/Dropbox/working papers/kmeans/R/km2gcn/R/km2gcn.R",
    "project_path" : "R/km2gcn.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}